# -*- coding: utf-8 -*-
"""duran_Assignment1_Svms.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1to9MJGfN1BISLLkeA_ZenVThjbsTFdnR
"""

# Add all imports
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import accuracy_score, classification_report

# Load the dataset
data = pd.read_csv('https://raw.githubusercontent.com/RoroDuran23/irisDS_CPSC393_ML/main/iris-1.csv?token=GHSAT0AAAAAACHJRH3PJD627UJU2NHDRPLSZIUOU3A')

# Encode the target variable 'Species'
label_encoder = LabelEncoder()
data['Species'] = label_encoder.fit_transform(data['Species'])

# Create X and y variables
# Split the dataset into training (70%), validation (10%), and testing (20%)
X = data[['PetalWidthCm', 'PetalLengthCm', 'SepalWidthCm', 'SepalLengthCm']]
y = data['Species']

X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42)
X_valid, X_test, y_valid, y_test = train_test_split(X_temp, y_temp, test_size=2/3, random_state=42)

# Create the model
svm_classifier = SVC(kernel='poly', C=0.00001, gamma= 1)

# Define a grid of hyperparameters
param_grid = {'kernel': ['linear', 'rbf', 'poly', 'sigmoid'],
              'C': [0.000001, 0.00001, 0.0001, 0.001, 0.01, 0.1, 0.5, 1],
              'gamma': ['scale', 'auto', 0.1, 1]}

# Perform grid search with cross-validation
grid_search = GridSearchCV(svm_classifier, param_grid, cv=5)
grid_search.fit(X_train, y_train)

# Get the best combination of hyperparameters
best_params = grid_search.best_params_
best_params

# Fit the model
svm_classifier.fit(X_train, y_train)

# Validate the dataset
y_val_pred = svm_classifier.predict(X_valid)
accuracy_val = accuracy_score(y_valid, y_val_pred)
print(f'Validation Accuracy: {accuracy_val:.2f}')

# Predict / y-hat
y_pred = svm_classifier.predict(X_test)

accuracy = accuracy_score(y_test, y_pred)
print(f'Accuracy: {accuracy:.2f}')

report = classification_report(y_test, y_pred)
print(report)

# Calculate SSE (Sum of Squared Errors)
sse = ((y_test - y_pred) ** 2).sum()

# Calculate MSE (Mean Squared Error)
mse = mean_squared_error(y_test, y_pred)

print(f"SSE: {sse:.2f}")
print(f"MSE: {mse:.2f}")

"""# For Plotting Purposes Only"""

# Create another SVM model with simpler parameters
svm_classifier = SVC(kernel='linear', C=1)

# Fit the model on the training data (Petal)
svm_classifier.fit(X_train[['PetalWidthCm', 'PetalLengthCm']], y_train)

# Plot the decision boundary for 'PetalWidthCm' and 'PetalLengthCm'
x_min, x_max = X_train['PetalWidthCm'].min() - 1, X_train['PetalWidthCm'].max() + 1
y_min, y_max = X_train['PetalLengthCm'].min() - 1, X_train['PetalLengthCm'].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.01), np.arange(y_min, y_max, 0.01))

# Classify points
Z = svm_classifier.decision_function(np.c_[xx.ravel(), yy.ravel()])
Z = Z.reshape(xx.shape)

# Plot
plt.figure()
plt.contourf(xx, yy, Z, cmap=plt.cm.Paired, alpha=0.8, levels=[-1, 0, 1], linestyles=['--', '-', '--'])
scatter = plt.scatter(X_train['PetalWidthCm'], X_train['PetalLengthCm'], c=y_train, cmap=plt.cm.Paired)
plt.xlabel('PetalWidthCm')
plt.ylabel('PetalLengthCm')
plt.title('SVM Decision Boundary for PetalWidthCm and PetalLengthCm')

# Add a legend
plt.legend(*scatter.legend_elements(), title="Classes")

plt.show()

# Fit the model on the training data (Sepal)
svm_classifier.fit(X_train[['SepalWidthCm', 'SepalLengthCm']], y_train)

# Plot the decision boundary for 'SepalWidthCm' and 'SepalLengthCm'
x_min, x_max = X_train['SepalWidthCm'].min() - 1, X_train['SepalWidthCm'].max() + 1
y_min, y_max = X_train['SepalLengthCm'].min() - 1, X_train['SepalLengthCm'].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.01), np.arange(y_min, y_max, 0.01))

Z = svm_classifier.decision_function(np.c_[xx.ravel(), yy.ravel()])
Z = Z.reshape(xx.shape)

plt.figure()
plt.contourf(xx, yy, Z, cmap=plt.cm.Paired, alpha=0.8, levels=[-1, 0, 1], linestyles=['--', '-', '--'])
scatter = plt.scatter(X_train['SepalWidthCm'], X_train['SepalLengthCm'], c=y_train, cmap=plt.cm.Paired)
plt.xlabel('SepalWidthCm')
plt.ylabel('SepalLengthCm')
plt.title('SVM Decision Boundary for SepalWidthCm and SepalLengthCm')

# Add a legend
plt.legend(*scatter.legend_elements(), title="Classes")

plt.show()